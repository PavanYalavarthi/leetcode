/*
problem credits: https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/description/

You are given a 0-indexed array nums and an integer target.

A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.

Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.

Solution:
    From total count, we get how many rounds of array is required.

    And remainder, We needed to find smallest len in circular array. (So, using 2n logic to convert circular to straight)
    
*/
class Solution {
public:
    int minSizeSubarray(vector<int>& nums, int target) {
        int n = nums.size();
        vector<long>prefixSum(2 * n + 1);
        prefixSum[0] =0;
        for(int i = 1; i < prefixSum.size(); i++) {
            prefixSum[i] = prefixSum[i-1] + nums[(i-1) % n];
        }
        long sum = prefixSum.back() / 2;
        long rem = target % sum, quot = target / sum;
        int start = 0, end = 0,minLen = INT_MAX;
        while(end < prefixSum.size() && start <= end) {
            int total = prefixSum[end] -prefixSum[start];
            if (total == rem) {
                minLen = min(minLen, end - start);
                start++, end++;
            } else if (total < rem) {
                end++;
            } else {
               start++;
            }
        }
        return (minLen == INT_MAX) ? -1 : (quot * n) + minLen;
    }
};